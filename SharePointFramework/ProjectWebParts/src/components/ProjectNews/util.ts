import { SPHttpClient } from '@microsoft/sp-http'
import * as strings from 'ProjectWebPartsStrings'
import { TemplateFile } from './types'


const GENERIC_NEWS_IMAGE = 'https://static2.sharepointonline.com/files/fabric/assets/brand-icons/product/svg/sharepoint_48x1.svg'
const KNOWN_PLACEHOLDER_IMAGES = [
  '/_layouts/15/images/sitepagethumbnail.png',
  'sitepagethumbnail.png',
  'cdn.hubblecontent.osi.office.net/m365content/publish/', // partial match for brown line images
]

// --- SharePoint file name validation constants ---
const invalidChars = /["*:<>?/\\|#%;]/g
const reservedNames = /^(con|prn|aux|nul|com[0-9]|lpt[0-9]|\.lock|desktop\.ini|_vti_|~\$|forms)$/i

/**
 * Validates a SharePoint file name according to SharePoint rules.
 * @param name The file name to validate (without path)
 * @returns true if valid, otherwise a localized error message string
 */
export function validateSharePointFileName(name: string): true | string {
  if (!name || name.trim().length === 0) {
    return strings.FileNameRequired
  }
  if (name.length > 100) {
    return strings.FileNameTooLong
  }
  if (invalidChars.test(name)) {
    return strings.FileNameInvalid
  }
  if (/^[. ]+|[. ]+$/.test(name)) {
    return strings.FileNameNoLeadingTrailingSpaces
  }
  if (reservedNames.test(name)) {
    return strings.FileNameReserved
  }
  return true
}

/**
 * Returns a server-relative URL by stripping the domain from siteUrl and joining with additional parts.
 * @param siteUrl The absolute site URL (e.g. https://tenant.sharepoint.com/sites/yoursite)
 * @param parts Additional path parts (e.g. 'SitePages', 'Project News', 'MyPage.aspx')
 * @returns The server-relative URL
 */
export function getServerRelativeUrl(siteUrl: string, ...parts: string[]): string {
  const sitePrefix = siteUrl.replace(/^https?:\/\/[^/]+/, '').replace(/\/$/, '')
  return [sitePrefix, ...parts].join('/').replace(/\/{2,}/g, '/')
}

/**
 * Ensures the existence of the specified news folder in the SitePages library.
 *
 * @param siteUrl URL of the site to check/create the folder in
 * @param spHttpClient SPHttpClient to use for the operation
 * @param folderName Name of the folder to ensure (default: 'Project News')
 * @returns Promise that resolves when the folder has been created or already exists
 */
export async function ensureProjectNewsFolder(
  siteUrl: string,
  spHttpClient: SPHttpClient,
  folderName: string
) {
  const folderServerRelativeUrl = getServerRelativeUrl(siteUrl, 'SitePages', folderName)
  const folderUrl = `${siteUrl}/_api/web/GetFolderByServerRelativeUrl('${folderServerRelativeUrl}')`
  const createFolderUrl = `${siteUrl}/_api/web/folders`

  const res = await spHttpClient.get(folderUrl, SPHttpClient.configurations.v1)
  if (res.ok) return

  if (res.status === 404) {
    const createRes = await spHttpClient.post(createFolderUrl, SPHttpClient.configurations.v1, {
      headers: {
        Accept: 'application/json',
        'Content-Type': 'application/json'
      },
      body: JSON.stringify({
        ServerRelativeUrl: folderServerRelativeUrl
      })
    })
    if (!createRes.ok) {
      const error = await createRes.json()
      throw new Error(
        strings.NewsFolderError + (error.error?.message?.value || createRes.statusText)
      )
    }
  } else {
    throw new Error(strings.NewsFolderError)
  }
}

/**
 * Returns a SharePoint page name suitable for a news article based on the given title.
 * Replaces spaces with dashes and appends '.aspx'.
 * @param title The title of the news article
 * @returns The generated SharePoint page name
 */
export function getNewsPageName(title: string): string {
  return `${title.replace(/\s+/g, '-')}.aspx`
}

/**
 * Returns the edit URL for a SharePoint page representing a news article.
 * @param siteUrl URL of the site containing the news article
 * @param folderName Name of the folder containing the news article page
 * @param pageName Name of the news article page (as generated by `getNewsPageName`)
 * @returns The edit URL for the news article page
 */
export function getNewsEditUrl(siteUrl: string, folderName: string, pageName: string): string {
  const serverRelative = getServerRelativeUrl(siteUrl, 'SitePages', folderName, pageName)
  const origin = new URL(siteUrl).origin
  return `${origin}${serverRelative}?Mode=Edit`

}

/**
 * Retrieves document templates from the 'Templates' folder in the SitePages library.
 * @param siteUrl URL of the site to retrieve the templates from
 * @param spHttpClient SPHttpClient to use for the operation
 * @returns Promise that resolves with an array of templates, represented as objects with `Name` and `ServerRelativeUrl` properties
 */
export async function getTemplates(siteUrl: string, spHttpClient: SPHttpClient): Promise<TemplateFile[]> {
  const url = `${siteUrl}/_api/web/GetFolderByServerRelativeUrl('SitePages/Templates')/Files?$select=Name,ServerRelativeUrl`
  try {
    const res = await spHttpClient.get(url, SPHttpClient.configurations.v1)
    const data = await res.json()
    return data.value || []
  } catch {
    return []
  }
}

/**
 * Copies a template page to a new location and promotes it as news.
 * @param siteUrl Site URL
 * @param spHttpClient SPHttpClient instance
 * @param selectedTemplate Server relative URL of the template file
 * @param newPageServerRelativeUrl Server relative URL for the new page
 * @param newPageName Name of the new page file (e.g. "My-Page.aspx")
 * @returns Promise<void>
 */
export async function copyAndPromoteNewsPage(
  siteUrl: string,
  spHttpClient: SPHttpClient,
  selectedTemplate: string,
  newPageServerRelativeUrl: string,
  newPageName: string
): Promise<void> {
  // Copy the template
  const copyUrl = `${siteUrl}/_api/web/GetFileByServerRelativeUrl('${selectedTemplate}')/copyTo(strNewUrl='${newPageServerRelativeUrl}',bOverWrite=false)`
  const res = await spHttpClient.post(copyUrl, SPHttpClient.configurations.v1, {
    headers: { Accept: 'application/json;odata=nometadata' }
  })
  if (!res.ok) {
    const error = await res.json()
    throw new Error('Copy failed: ' + (error.error?.message?.value || res.statusText))
  }

  // Retry logic to get the new item's ID
  const getListItemIdWithRetry = async (maxRetries = 5, delayMs = 500): Promise<number | undefined> => {
    const listItemUrl = `${siteUrl}/_api/web/lists/GetByTitle('Site Pages')/items?$filter=FileLeafRef eq '${newPageName}'`
    for (let attempt = 0; attempt < maxRetries; attempt++) {
      const listItemRes = await spHttpClient.get(listItemUrl, SPHttpClient.configurations.v1)
      const listItemData = await listItemRes.json()
      const itemId = listItemData.value?.[0]?.Id
      if (itemId) return itemId
      await new Promise(res => setTimeout(res, delayMs))
    }
    return undefined
  }

  const itemId = await getListItemIdWithRetry()
  if (!itemId) throw new Error('Could not find the list item for the new page after several attempts.')

  // Promote as news
  const updateUrl = `${siteUrl}/_api/web/lists/GetByTitle('Site Pages')/items(${itemId})`
  const updateRes = await spHttpClient.post(updateUrl, SPHttpClient.configurations.v1, {
    headers: {
      Accept: 'application/json;odata=nometadata',
      'Content-Type': 'application/json;odata=verbose',
      'IF-MATCH': '*',
      'X-HTTP-Method': 'MERGE'
    },
    body: JSON.stringify({
      PromotedState: 2,
      PageLayoutType: 'Article'
    })
  })
  console.log('Update response status:', updateRes)
  if (!updateRes.ok) {
    const error = await updateRes.json()
    throw new Error('Promote failed: ' + (error.error?.message?.value || updateRes.statusText))
  }
}



  /**
   * Given a SharePoint news item, extracts the URL of the banner image.
   * First looks at the BannerImageUrl field, then tries to extract the first
   * image URL from the CanvasContent1 field (if it's a JSON string).
   * Returns undefined if no image URL can be found.
   * @param item SharePoint news item
   */
export function getNewsImageUrl(item: any): string | undefined {
  if (item.BannerImageUrl?.Url) return item.BannerImageUrl.Url
  if (item.CanvasContent1) {
    try {
      const html = JSON.parse(item.CanvasContent1)
      const match = html.match(/<img[^>]+src="([^">]+)"/)
      if (match && match[1]) return match[1]
    } catch {
      // ignore parse errors
    }
  }
  return undefined
}
