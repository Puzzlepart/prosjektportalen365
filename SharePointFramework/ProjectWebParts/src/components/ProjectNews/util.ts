import { SPHttpClient, SPHttpClientResponse } from '@microsoft/sp-http'

import * as strings from 'ProjectWebPartsStrings'
import { TemplateFile } from './types'


// --- SharePoint file name validation constants ---
const invalidChars = /["*:<>?/\\|#%;]/g
const reservedNames = /^(con|prn|aux|nul|com[0-9]|lpt[0-9]|\.lock|desktop\.ini|_vti_|~\$|forms)$/i

/**
 * Validates a SharePoint file name according to SharePoint rules.
 * @param name The file name to validate (without path)
 * @returns true if valid, otherwise a localized error message string
 */
export function validateSharePointFileName(name: string): true | string {
  if (!name || name.trim().length === 0) {
    return strings.FileNameRequired
  }
  if (name.length > 100) {
    return strings.FileNameTooLong
  }
  if (invalidChars.test(name)) {
    return strings.FileNameInvalid
  }
  if (/^[. ]+|[. ]+$/.test(name)) {
    return strings.FileNameNoLeadingTrailingSpaces
  }
  if (reservedNames.test(name)) {
    return strings.FileNameReserved
  }
  return true
}

/**
 * Returns a server-relative URL by stripping the domain from siteUrl and joining with additional parts.
 * @param siteUrl The absolute site URL (e.g. https://tenant.sharepoint.com/sites/yoursite)
 * @param parts Additional path parts (e.g. 'SitePages', 'Project News', 'MyPage.aspx')
 * @returns The server-relative URL
 */
export function getServerRelativeUrl(siteUrl: string, ...parts: string[]): string {
  const sitePrefix = siteUrl.replace(/^https?:\/\/[^/]+/, '').replace(/\/$/, '')
  return [sitePrefix, ...parts].join('/').replace(/\/{2,}/g, '/')
}

/**
 * Ensures the existence of the specified news folder in the SitePages library.
 *
 * @param siteUrl URL of the site to check/create the folder in
 * @param spHttpClient SPHttpClient to use for the operation
 * @param folderName Name of the folder to ensure (default: 'Project News')
 * @returns Promise that resolves when the folder has been created or already exists
 */
export async function ensureProjectNewsFolder(
  siteUrl: string,
  spHttpClient: SPHttpClient,
  folderName: string
) {
  const folderServerRelativeUrl = getServerRelativeUrl(siteUrl, 'SitePages', folderName)
  const folderUrl = `${siteUrl}/_api/web/GetFolderByServerRelativeUrl('${folderServerRelativeUrl}')`
  const createFolderUrl = `${siteUrl}/_api/web/folders`

  const res = await spHttpClient.get(folderUrl, SPHttpClient.configurations.v1)
  if (res.ok) return

  if (res.status === 404) {
    const createRes = await spHttpClient.post(createFolderUrl, SPHttpClient.configurations.v1, {
      headers: {
        Accept: 'application/json',
        'Content-Type': 'application/json'
      },
      body: JSON.stringify({
        ServerRelativeUrl: folderServerRelativeUrl
      })
    })
    if (!createRes.ok) {
      const error = await createRes.json()
      throw new Error(
        strings.NewsFolderError + (error.error?.message?.value || createRes.statusText)
      )
    }
  } else {
    throw new Error(strings.NewsFolderError)
  }
}

/**
 * Returns a SharePoint page name suitable for a news article based on the given title.
 * Replaces spaces with dashes and appends '.aspx'.
 * @param title The title of the news article
 * @returns The generated SharePoint page name
 */
export function getNewsPageName(title: string): string {
  return `${title.replace(/\s+/g, '-')}.aspx`
}

/**
 * Returns the edit URL for a SharePoint page representing a news article.
 * @param siteUrl URL of the site containing the news article
 * @param folderName Name of the folder containing the news article page
 * @param pageName Name of the news article page (as generated by `getNewsPageName`)
 * @returns The edit URL for the news article page
 */
export function getNewsEditUrl(siteUrl: string, folderName: string, pageName: string): string {
  const serverRelative = getServerRelativeUrl(siteUrl, 'SitePages', folderName, pageName)
  const origin = new URL(siteUrl).origin
  return `${origin}${serverRelative}?Mode=Edit`

}

/**
 * Retrieves document templates from the 'Templates' folder in the SitePages library.
 * @param siteUrl URL of the site to retrieve the templates from
 * @param spHttpClient SPHttpClient to use for the operation
 * @returns Promise that resolves with an array of templates, represented as objects with `Name` and `ServerRelativeUrl` properties
 */
export async function getTemplates(siteUrl: string, spHttpClient: SPHttpClient): Promise<TemplateFile[]> {
  const url = `${siteUrl}/_api/web/GetFolderByServerRelativeUrl('SitePages/Templates')/Files?$select=Name,ServerRelativeUrl`
  try {
    const res = await spHttpClient.get(url, SPHttpClient.configurations.v1)
    const data = await res.json()
    return data.value || []
  } catch {
    return []
  }
}

/**
 * Promotes a SharePoint site page to a news article by updating its PromotedState
 * and PageLayoutType properties.
 *
 * @param siteUrl URL of the SharePoint site
 * @param spHttpClient SPHttpClient instance to perform the HTTP request
 * @param sitePagesServerRelativeUrl Server-relative URL of the SitePages library
 * @param itemId ID of the list item representing the page to be promoted
 * @returns Promise that resolves when the page has been successfully promoted or rejects with an error
 *          if the promotion fails
 * @throws Error if the HTTP request fails or the response is not successful
 */
export async function promotePageToNewsArticle(
  siteUrl: string,
  spHttpClient: SPHttpClient,
  sitePagesServerRelativeUrl: string,
  itemId: number
): Promise<void> {
  const updateUrl = `${siteUrl}/_api/web/GetListUsingPath(DecodedUrl='${sitePagesServerRelativeUrl}')/items(${itemId})`
  const updateRes = await spHttpClient.post(
    updateUrl,
    SPHttpClient.configurations.v1,
    {
      headers: {
        Accept: 'application/json',
        'Content-Type': 'application/json',
        'IF-MATCH': '*',
        'X-HTTP-Method': 'MERGE'
      },
      body: JSON.stringify({
        PromotedState: 2,
        PageLayoutType: 'Article'
      })
    }
  )
  if (!updateRes.ok) {
    const error = await updateRes.json()
    throw new Error(error?.error?.message?.value || updateRes.statusText)
  }
}



  /**
   * Given a SharePoint news item, extracts the URL of the banner image.
   * First looks at the BannerImageUrl field, then tries to extract the first
   * image URL from the CanvasContent1 field (if it's a JSON string).
   * Returns undefined if no image URL can be found.
   * @param item SharePoint news item
   */
export function getNewsImageUrl(item: any): string | undefined {
  if (item.BannerImageUrl?.Url) return item.BannerImageUrl.Url
  if (item.CanvasContent1) {
    try {
      const html = JSON.parse(item.CanvasContent1)
      const match = html.match(/<img[^>]+src="([^">]+)"/)
      if (match && match[1]) return match[1]
    } catch {
      // ignore parse errors
    }
  }
  return undefined
}


/**
 * Extracts and returns a user-friendly error message from a SharePoint error object.
 * It checks various properties of the error object to find the most relevant message.
 * If no specific message is found, it returns the stringified error object or an empty string.
 *
 * @param error The SharePoint error object.
 * @returns The extracted error message as a string.
 */
export function extractSharePointErrorMessage(error: any): string {
  return (
    error?.error?.message?.value ||
    error?.error?.message ||
    error?.error?.code ||
    error?.message ||
    JSON.stringify(error) ||
    ''
  )
}


/**
 * Retrieves the list item ID for a SharePoint site page given its file name.
 *
 * @param siteUrl URL of the SharePoint site
 * @param spHttpClient SPHttpClient instance to use for making the request
 * @param fileName Name of the file to find the item ID for
 * @returns Promise that resolves with an object containing the item ID (if found)
 *          and the server-relative URL of the SitePages library
 */
export async function getSitePageItemIdByFileName(
  siteUrl: string,
  spHttpClient: SPHttpClient,
  fileName: string
): Promise<{ itemId?: number, sitePagesServerRelativeUrl: string }> {
  const sitePagesServerRelativeUrl = getServerRelativeUrl(siteUrl, 'SitePages')
  const listItemUrl = `${siteUrl}/_api/web/GetListUsingPath(DecodedUrl=@a1)/items?@a1='${sitePagesServerRelativeUrl}'&$filter=FileLeafRef eq '${fileName}'`
  const listItemRes = await spHttpClient.get(listItemUrl, SPHttpClient.configurations.v1)
  const listItemData = await listItemRes.json()
  const itemId = listItemData.value?.[0]?.Id
  return { itemId, sitePagesServerRelativeUrl }
}

/**
 * Copies a template page to a new server-relative URL.
 *
 * @param siteUrl URL of the SharePoint site
 * @param spHttpClient SPHttpClient instance to use for making the request
 * @param selectedTemplate Server-relative URL of the template page to copy
 * @param newPageServerRelativeUrl Server-relative URL to copy the template page to
 * @returns Promise that resolves with the raw response from the REST request
 */
export async function copyTemplatePage(
  siteUrl: string,
  spHttpClient: SPHttpClient,
  selectedTemplate: string,
  newPageServerRelativeUrl: string
): Promise<SPHttpClientResponse> {
  const copyUrl = `${siteUrl}/_api/web/GetFileByServerRelativeUrl('${selectedTemplate}')/copyTo(strNewUrl='${newPageServerRelativeUrl}',bOverWrite=false)`
  return spHttpClient.post(copyUrl, SPHttpClient.configurations.v1, {
    headers: { Accept: 'application/json;odata=nometadata' }
  })
}
