import { SPHttpClient, SPHttpClientResponse } from '@microsoft/sp-http'

import * as strings from 'ProjectWebPartsStrings'
import { NewsItem, TemplateFile } from './types'

// --- SharePoint file name validation constants ---
const invalidChars = /["*:<>?/\\|#%;]/g
const reservedNames = /^(con|prn|aux|nul|com[0-9]|lpt[0-9]|\.lock|desktop\.ini|_vti_|~\$|forms)$/i

/**
 * Validates a SharePoint file name according to SharePoint rules.
 * @param name The file name to validate (without path)
 * @returns true if valid, otherwise a localized error message string
 */
export function validateSharePointFileName(name: string): true | string {
  if (!name || name.trim().length === 0) {
    return strings.FileNameRequired
  }
  if (name.length > 100) {
    return strings.FileNameTooLong
  }
  if (invalidChars.test(name)) {
    return strings.FileNameInvalid
  }
  if (/^[. ]+|[. ]+$/.test(name)) {
    return strings.FileNameNoLeadingTrailingSpaces
  }
  if (reservedNames.test(name)) {
    return strings.FileNameReserved
  }
  return true
}

/**
 * Returns a server-relative URL by stripping the domain from siteUrl and joining with additional parts.
 * @param siteUrl The absolute site URL (e.g. https://tenant.sharepoint.com/sites/yoursite)
 * @param parts Additional path parts (e.g. 'SitePages', 'Project News', 'MyPage.aspx')
 * @returns The server-relative URL
 */
export function getServerRelativeUrl(siteUrl: string, ...parts: string[]): string {
  const sitePrefix = siteUrl.replace(/^https?:\/\/[^/]+/, '').replace(/\/$/, '')
  return [sitePrefix, ...parts].join('/').replace(/\/{2,}/g, '/')
}

/**
 * Ensures the existence of the specified news folder in the SitePages library.
 *
 * @param siteUrl URL of the site to check/create the folder in
 * @param spHttpClient SPHttpClient to use for the operation
 * @param folderName Name of the folder to ensure (default: 'Project News')
 * @returns Promise that resolves when the folder has been created or already exists
 */
export async function ensureProjectNewsFolder(
  siteUrl: string,
  spHttpClient: SPHttpClient,
  folderName: string
) {
  const folderServerRelativeUrl = getServerRelativeUrl(siteUrl, 'SitePages', folderName)
  const folderUrl = `${siteUrl}/_api/web/GetFolderByServerRelativeUrl('${folderServerRelativeUrl}')`
  const createFolderUrl = `${siteUrl}/_api/web/folders`

  const res = await spHttpClient.get(folderUrl, SPHttpClient.configurations.v1)
  if (res.ok) return

  if (res.status === 404) {
    const createRes = await spHttpClient.post(createFolderUrl, SPHttpClient.configurations.v1, {
      headers: {
        Accept: 'application/json',
        'Content-Type': 'application/json'
      },
      body: JSON.stringify({
        ServerRelativeUrl: folderServerRelativeUrl
      })
    })
    if (!createRes.ok) {
      const error = await createRes.json()
      throw new Error(
        strings.NewsFolderError + (error.error?.message?.value || createRes.statusText)
      )
    }
  } else {
    throw new Error(strings.NewsFolderError)
  }
}

/**
 * Returns a SharePoint page name suitable for a news article based on the given title.
 * Replaces spaces with dashes and appends '.aspx'.
 * @param title The title of the news article
 * @returns The generated SharePoint page name
 */
export function getNewsPageName(title: string): string {
  return `${title.replace(/\s+/g, '-')}.aspx`
}

/**
 * Returns the edit URL for a SharePoint page representing a news article.
 * @param siteUrl URL of the site containing the news article
 * @param folderName Name of the folder containing the news article page
 * @param pageName Name of the news article page (as generated by `getNewsPageName`)
 * @returns The edit URL for the news article page
 */
export function getNewsEditUrl(siteUrl: string, folderName: string, pageName: string): string {
  const serverRelative = getServerRelativeUrl(siteUrl, 'SitePages', folderName, pageName)
  const origin = new URL(siteUrl).origin
  return `${origin}${serverRelative}?Mode=Edit`
}

/**
 * Retrieves document templates from the 'Templates' folder in the SitePages library.
 * @param siteUrl URL of the site to retrieve the templates from
 * @param spHttpClient SPHttpClient to use for the operation
 * @returns Promise that resolves with an array of templates, represented as objects with `Name` and `ServerRelativeUrl` properties
 */
export async function getTemplates(
  siteUrl: string,
  spHttpClient: SPHttpClient
): Promise<TemplateFile[]> {
  const url = `${siteUrl}/_api/web/GetFolderByServerRelativeUrl('SitePages/Templates')/Files?$select=Name,ServerRelativeUrl`
  try {
    const res = await spHttpClient.get(url, SPHttpClient.configurations.v1)
    const data = await res.json()
    return data.value || []
  } catch {
    return []
  }
}

/**
 * Promotes a SharePoint site page to a news article by updating its PromotedState
 * and PageLayoutType properties.
 *
 * @param siteUrl URL of the SharePoint site
 * @param spHttpClient SPHttpClient instance to perform the HTTP request
 * @param sitePagesServerRelativeUrl Server-relative URL of the SitePages library
 * @param itemId ID of the list item representing the page to be promoted
 * @returns Promise that resolves when the page has been successfully promoted or rejects with an error
 *          if the promotion fails
 * @throws Error if the HTTP request fails or the response is not successful
 */
export async function promotePageToNewsArticle(
  siteUrl: string,
  spHttpClient: SPHttpClient,
  itemId: number
): Promise<void> {
  const promoteUrl = `${siteUrl}/_api/sitepages/pages(${itemId})/PromoteToNews`
  const res = await spHttpClient.post(promoteUrl, SPHttpClient.configurations.v1, {
    headers: {
      Accept: 'application/json',
      'Content-Type': 'application/json'
    },
    body: JSON.stringify({
      __metadata: { type: 'SP.Publishing.SitePage' }
    })
  })
  if (!res.ok) {
    const error = await res.json()
    throw new Error(error?.error?.message?.value || res.statusText)
  }
}

/**
 * Ensures that all news items are promoted to news articles.
 * This function goes through all news items in Recent News List and if the item is not already promoted (PromotedState === 2),
 * it will call the promotePageToNewsArticle function to promote the page.
 *
 * @param siteUrl URL of the SharePoint site
 * @param spHttpClient SPHttpClient instance to perform the HTTP request
 * @param newsItems An array of news items to ensure are promoted
 * @returns Promise that resolves when all news items have been successfully promoted or rejects with an error
 *          if one of the promotion fails
 */
export async function ensureAllNewsPromoted(
  siteUrl: string,
  spHttpClient: SPHttpClient,
  newsItems: NewsItem[],
  folderName: string
): Promise<void> {
  if (!newsItems || newsItems.length === 0) {
    console.warn('No news items to promote.')
    return
  }
  const folderServerRelativeUrl = getServerRelativeUrl(siteUrl, 'SitePages', folderName)
  for (const item of newsItems) {
    if (
      item.PromotedState !== 2 &&
      item.Id &&
      (item.url?.toLowerCase().startsWith(folderServerRelativeUrl.toLowerCase() + '/') ||
        item.url?.toLowerCase() === folderServerRelativeUrl.toLowerCase())
    ) {
      try {
        await promotePageToNewsArticle(siteUrl, spHttpClient, item.Id)
      } catch (err) {
        console.warn(`Failed to promote page ${item.name} (ID: ${item.Id}):`, err)
      }
    }
  }
}

/**
 * Given a SharePoint news item, extracts the URL of the banner image.
 * First looks at the BannerImageUrl field, then tries to extract the first
 * image URL from the CanvasContent1 field (if it's a JSON string).
 * Returns undefined if no image URL can be found.
 * @param item SharePoint news item
 */
export function getNewsImageUrl(item: any): string | undefined {
  if (item.BannerImageUrl?.Url) return item.BannerImageUrl.Url
  if (item.CanvasContent1) {
    try {
      const html = JSON.parse(item.CanvasContent1)
      const match = html.match(/<img[^>]+src="([^">]+)"/)
      if (match && match[1]) return match[1]
    } catch {
      // ignore parse errors
    }
  }
  return undefined
}

/**
 * Checks if a SharePoint site page exists.
 *
 * @param siteUrl URL of the SharePoint site
 * @param spHttpClient SPHttpClient instance to perform the HTTP request
 * @param folderName Name of the folder in the SitePages library where the page is located
 * @param fileName File name of the page
 * @returns Promise that resolves with a boolean indicating if the file exists or not.
 */
export async function doesSitePageExist(
  siteUrl: string,
  spHttpClient: SPHttpClient,
  folderName: string,
  fileName: string
): Promise<boolean> {
  const serverRelativeUrl = getServerRelativeUrl(siteUrl, 'SitePages', folderName, fileName)
  const url = `${siteUrl}/_api/web/GetFileByServerRelativeUrl('${serverRelativeUrl}')`
  const res = await spHttpClient.get(url, SPHttpClient.configurations.v1)
  return res.ok
}

/**
 * Retrieves the list item ID for a SharePoint site page given its file name.
 *
 * @param siteUrl URL of the SharePoint site
 * @param spHttpClient SPHttpClient instance to use for making the request
 * @param fileName Name of the file to find the item ID for
 * @returns Promise that resolves with an object containing the item ID (if found)
 *          and the server-relative URL of the SitePages library
 */
export async function getSitePageItemIdByFileName(
  siteUrl: string,
  spHttpClient: SPHttpClient,
  fileName: string
): Promise<{ itemId?: number; sitePagesServerRelativeUrl: string }> {
  const sitePagesServerRelativeUrl = getServerRelativeUrl(siteUrl, 'SitePages')
  const listItemUrl = `${siteUrl}/_api/web/GetListUsingPath(DecodedUrl=@a1)/items?@a1='${sitePagesServerRelativeUrl}'&$filter=FileLeafRef eq '${fileName}'`
  const listItemRes = await spHttpClient.get(listItemUrl, SPHttpClient.configurations.v1)
  const listItemData = await listItemRes.json()
  const itemId = listItemData.value?.[0]?.Id
  return { itemId, sitePagesServerRelativeUrl }
}

/**
 * Copies a template page to a new server-relative URL.
 *
 * @param siteUrl URL of the SharePoint site
 * @param spHttpClient SPHttpClient instance to use for making the request
 * @param selectedTemplate Server-relative URL of the template page to copy
 * @param newPageServerRelativeUrl Server-relative URL to copy the template page to
 * @returns Promise that resolves with the raw response from the REST request
 */
export async function copyTemplatePage(
  siteUrl: string,
  spHttpClient: SPHttpClient,
  selectedTemplate: string,
  newPageServerRelativeUrl: string
): Promise<SPHttpClientResponse> {
  const copyUrl = `${siteUrl}/_api/web/GetFileByServerRelativeUrl('${selectedTemplate}')/copyTo(strNewUrl='${newPageServerRelativeUrl}',bOverWrite=false)`
  return spHttpClient.post(copyUrl, SPHttpClient.configurations.v1, {
    headers: { Accept: 'application/json;odata=nometadata' }
  })
}

/**
 * Sets the "Original Source Site Id" field for a Site Page item.
 * @param siteUrl URL of the SharePoint site where the page is stored
 * @param spHttpClient SPHttpClient instance to use for making the request
 * @param sitePagesServerRelativeUrl Server-relative URL of the SitePages library
 * @param itemId ID of the list item representing the page
 * @param siteId The ID of the source site to set in the OriginalSourceSiteId field
 * @returns Promise that resolves when the field has been set
 */
export async function setOriginalSourceSiteId(
  siteUrl: string,
  spHttpClient: SPHttpClient,
  sitePagesServerRelativeUrl: string,
  itemId: number,
  siteId: string
): Promise<void> {
  if (!siteId) {
    throw new Error('Site ID is required to set OriginalSourceSiteId')
  }
  const updateUrl = `${siteUrl}/_api/web/GetListUsingPath(DecodedUrl='${sitePagesServerRelativeUrl}')/items(${itemId})`
  const updateRes = await spHttpClient.post(updateUrl, SPHttpClient.configurations.v1, {
    headers: {
      Accept: 'application/json',
      'Content-Type': 'application/json',
      'IF-MATCH': '*',
      'X-HTTP-Method': 'MERGE'
    },
    body: JSON.stringify({
      SourceSiteId: siteId // NB! change from SourceSiteId to use GtSiteId
    })
  })
  if (!updateRes.ok) {
    const error = await updateRes.json()
    throw new Error(error?.error?.message?.value || updateRes.statusText)
  }
}

